% !TEX program = xelatex
% !TEX root = ../main.tex

\section{Applications}

\subsection{GÃ©nÃ©ralitÃ©s}
Dans la suite \(ğ¸\), \(ğ¹\), \(ğº\)... dÃ©signent des ensembles quelconques dont les propriÃ©tÃ©s sont prÃ©cisÃ©es
selon les besoins.

\begin{definition}
[Application]
Une \mykeyword{application} \(ğ‘“\) est la donnÃ©e de
\begin{enumerate}
\itemrnd un ensemble \(ğ¸\), l'\mykeyword{ensemble de dÃ©part},
\itemrnd un ensemble \(ğ¹\), l'\mykeyword{ensemble d'arrivÃ©e},
\itemrnd une partie \(Î“\) de \(ğ¸Ã—ğ¹\), le
\mykeyword{graphe}, telle que
\begin{equation*}
âˆ€ğ‘¥âˆˆğ¸\text{, }âˆƒ!ğ‘¦âˆˆğ¹\text{, }(ğ‘¥;ğ‘¦)âˆˆÎ“
\end{equation*}
\end{enumerate}
Pour \((ğ‘¥~;ğ‘¦)\) de \(Î“\), \(ğ‘¦\) est l'\mykeyword{image} de \(ğ‘¥\) par
\(ğ‘“\), notÃ©e \(ğ‘“(ğ‘¥)\). \(ğ‘¥\) est un \mykeyword{antÃ©cÃ©dent} de
\(ğ‘¦\) par \(ğ‘“\), l'ensemble de tous les antÃ©cÃ©dents de \(ğ‘¦\) est notÃ©
\(\overset{-1}{ğ‘“}(ğ‘¦)\), c'est l'\mykeyword{image rÃ©ciproque} ou
\mykeyword{prÃ© image} de \(ğ‘¦\) par \(ğ‘“\). \(ğ‘¦\) est
\mykeyword{associÃ© Ã } \(ğ‘¥\) par \(ğ‘“\).
\end{definition}
%
\begin{remark}
Deux applications sont Ã©gales si et seulement si elles ont mÃªme
ensemble de dÃ©part, mÃªme ensemble d'arrivÃ©e et mÃªme graphe.
\end{remark}
%
\begin{definition}
L'ensemble des applications de \(ğ¸\) dans \(ğ¹\) est notÃ© \(ğ¹^{ğ¸}\).

\(ğ‘“~:ğ¸â†’ğ¹\) dÃ©signe une application de \(ğ¸\) dans \(ğ¹\) nommÃ©e \(ğ‘“\).
 On peut rencontrer la notation
\(ğ‘“\;:\;ğ¸â†ªğ¹\).
\end{definition}
\begin{equation*}
\begin{matrix}
ğ‘“~:&ğ¸&âŸ¶&ğ¹\\&ğ‘¥&âŸ¼&\text{une formule}
\end{matrix}
\end{equation*}
dÃ©signe l'application de \(ğ¸\) dans \(ğ¹\) nommÃ©e \(ğ‘“\) qui Ã  \(ğ‘¥\) associe \(\text{une
formule}\).

\begin{theorem}
Il n'existe qu'un seule application de \(âˆ…\) dans \(ğ¹\), son graphe est \(âˆ…\).
On la dÃ©signe par \mykeyword{application vide}.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
%
\begin{theorem}
[Application de choix]
Ã‰tant donnÃ©e une partition \(ğ‘ƒ\) de \(ğ¸\),
il existe une application de choix \(ğœ‘~:ğ‘ƒâ†’ğ¸\) telle que pour tout \(ğ¹\) de
\(ğ‘ƒ\), on a \ \(ğœ‘(ğ¹)âˆˆğ¹\).
\end{theorem}
\begin{proof}
L'axiome du choix appliquÃ© Ã  la partition \(ğ‘ƒ\) donne un ensemble \(ğº\)
qui contient un seul Ã©lÃ©ment par composante de la partition.
\(\left\{(ğ‘¥~;ğ‘¦)\left|âˆˆğ‘¥âˆˆğ‘ƒ~\text{ et }~ğ‘¦âˆˆğ‘¥âˆ©ğ¸\right.\right\}\)
est un graphe qui rÃ©pond Ã  la question. Ã€ dÃ©tailler...
\end{proof}
%
\begin{definition}
[Prolongement, restriction]
Soit \(ğ‘“~:ğ¸â†’ğ¹\) et \(ğ‘”~:ğºâ†’ğ¹\), de graphes respectifs \(Î“_{ğ‘“}\) et \(Î“_{ğ‘”}\). \(ğ‘“\) est une
\mykeyword{restriction} de \(ğ‘”\) ou \(ğ‘”\) est un \mykeyword{prolongement} de \(ğ‘“\) signifie
que \(ğ¸âŠ‚ğº\) et \(Î“_{ğ‘“}âŠ‚Î“_{ğ‘”}\). \(ğ‘”\) est aussi notÃ©e \(ğ‘“_{\left|ğº\right.}\), lu Â«~ \(ğ‘“\) restreinte Ã  \(ğº\)~Â».
\end{definition}
\begin{remark}
On garde le mÃªme ensemble d'arrivÃ©e.
\end{remark}
%
\subsection{Injection}
\begin{definition}
[Injection]
\(ğ¸\) et \(ğ¹\) Ã©tant des ensembles, une application \(ğ‘“\) de
\(ğ¸\) dans \(ğ¹\) est \mykeyword{injective} ou de maniÃ¨re synonyme une
\mykeyword{injection} signifie que
\begin{equation*}
âˆ€ğ‘¥,ğ‘¥'âˆˆğ¸,\;(ğ‘“(ğ‘¥)=ğ‘“(ğ‘¥')âŸ¹ğ‘¥=ğ‘¥')
\end{equation*}
ou par contraposition
\begin{equation*}
âˆ€ğ‘¥,ğ‘¥'âˆˆğ¸,\;(ğ‘¥â‰ ğ‘¥'âŸ¹ğ‘“(ğ‘¥)â‰ ğ‘“(ğ‘¥'))
\end{equation*}
L'ensemble des injections de \(ğ¸\) dans \(ğ¹\) est notÃ© \(I(ğ¸~;ğ¹)\).
\end{definition}
%
\begin{theorem}
Une application vide est injective.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
%
\begin{theorem}
Toute restriction d'une injection est une injection.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
%
\begin{definition}
[Image rÃ©ciproque]
\(ğ¸\) et \(ğ¹\) Ã©tant des ensembles, \(ğ‘“\) une application de \(ğ¸\) dans \(ğ¹\).
Pour un ensemble \(ğº\), l'\mykeyword{image rÃ©ciproque} de \(ğº\) par \(ğ‘“\) est
\(\left\{ğ‘¥âˆˆğ¸\middle|âˆƒğ‘¦âˆˆğº\text{, }ğ‘¦=ğ‘“(ğ‘¥)\right\}\),
notÃ©e \(\overset{-1}{ğ‘“}(ğº)\).
\end{definition}
\begin{remark}
\(\overset{-1}{ğ‘“}(ğº)\) est \(\overset{-1}{ğ‘“}(ğ‘¦)\) si \(ğº\) est le singleton \(\left\{ğ‘¦\right\}\).
\end{remark}
%
\begin{theorem}
[Image rÃ©ciproque]
\(ğ¸\) et \(ğ¹\) Ã©tant des ensembles, \(ğ‘“\) une application de \(ğ¸\) dans \(ğ¹\).
Pour un ensemble \(ğº\),
\begin{equation*}
\left\{ğ‘¥âˆˆğ¸\middle|âˆƒğ‘¦âˆˆğº\text{, }ğ‘¦=ğ‘“(ğ‘¥)\right\}=
\bigcup_{ğ‘¦âˆˆğº}\overset{-1}{ğ‘“}(ğ‘¦)
\end{equation*}
C'est l'\mykeyword{image rÃ©ciproque} ou \mykeyword{prÃ© image} de \(ğº\) par \(ğ‘“\),
notÃ©e \(\overset{-1}{ğ‘“}(ğº)\), c'est aussi \(\overset{-1}{ğ‘“}(ğ‘¦)\) si \(ğº\)
est le singleton \(\left\{ğ‘¦\right\}\).
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
%
\begin{theorem}
\label{thm:injection}
Une application \(ğ‘“\) est une injection si et seulement si pour tout \(ğ‘¦\), \(\overset{-1}{ğ‘“}(ğ‘¦)\) est
vide ou un singleton.
\end{theorem}
\begin{proof}
S'il n'est pas vide, \(\overset{-1}{ğ‘“}(ğ‘¦)\) contient \(ğ‘¥_0\) et par dÃ©finition de l'image rÃ©ciproque, \(ğ‘¦=ğ‘“(ğ‘¥_0)\).
Comme \(ğ‘“\) est injective, en particulier
\begin{equation*}
âˆ€ğ‘¥âˆˆğ¸\text{, }(ğ‘¥âˆˆ\overset{-1}{ğ‘“}(ğ‘¦)
\overset{\text{\scriptsize dÃ©f}}{âŸ¹}
ğ‘“(ğ‘¥)=ğ‘¦
âŸ¹
ğ‘¥=ğ‘¥_0
\end{equation*}
d'oÃ¹ \(\overset{-1}{ğ‘“}(ğ‘¦)\) est le singleton \(\{ğ‘¥_0\}\).
\end{proof}
%
\begin{definition}
[Injection canonique]
Ã‰tant donnÃ© \(ğ¹âŠ‚ğ¸\), l'\mykeyword{injection}
\index{injection!canonique}\mykeyword{canonique} de \(ğ¹\) dans \(ğ¸\) est l'application qui Ã 
tout Ã©lÃ©ment associe lui-mÃªme.
\end{definition}
%
\begin{definition}
L'injection canonique est une injection.
\end{definition}
\begin{proof}
En exercice...
\end{proof}
%
\begin{definition}
[Ensemble infini]
Un ensemble \(ğ¸\) est infini s'il existe une injection de lui-mÃªme dans
un de ses sous-ensembles stricts :
\begin{equation*}
ğ¸\text{ est infini}\overset{\text{\scriptsize dÃ©f}}{âŸº}âˆƒğ¹âŠŠğ¸,\;âˆƒğ›·\;:\;ğ¸â†ªğ¹
\end{equation*}
\end{definition}
\begin{definition}
[Ensemble dÃ©nombrable)]
Un ensemble \(ğ¸\) est \index{dÃ©nombrable}\mykeyword{dÃ©nombrable} signifie qu'il existe une
injection de \(ğ¸\) dans \(â„•\).
\end{definition}
\begin{exercise}
\(â„•^2\) est dÃ©nombrable, on vÃ©rifie que \((ğ‘š,ğ‘›)â†¦2^{ğ‘š}3^{ğ‘›}\) est une injection de \(â„•^2\) dans \(â„•\).
GÃ©nÃ©raliser Ã  \(â„•^{ğ‘˜}\) , \(ğ‘˜âˆˆâ„•\).
\(â„\) et \(â„•^â„•\) ne sont pas dÃ©nombrables.
\end{exercise}
\subsection{Surjection}
\begin{definition}
[Surjection]
\(ğ¸\) et \(ğ¹\) Ã©tant des ensembles, une application \(ğ‘“\)
de \(ğ¸\) dans \(ğ¹\) est \mykeyword{surjective}, ou de maniÃ¨re synonyme une
\mykeyword{surjection}, signifie que
\(âˆ€ğ‘¦âˆˆğ¹,âˆƒğ‘¥âˆˆğ¸,ğ‘¦=ğ‘“(ğ‘¥)\).
\end{definition}
\begin{remark}
Pour une formulation textuelle : tout Ã©lÃ©ment de l'ensemble d'arrivÃ©e a au moins un antÃ©cÃ©dent.
\end{remark}
%
\begin{theorem}
L'application vide de \(âˆ…\) dans lui-mÃªme est surjective.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
%
\begin{theorem}
\label{thm:surjection}
Une application \(ğ‘“\) est une surjection si et seulement si pour tout \(ğ‘¦\) de son ensemble d'arrivÃ©e,
 \(\overset{-1}{ğ‘“}(ğ‘¦)\) n'est pas vide.
 \end{theorem}
\begin{proof}
On a \(âˆƒğ‘¥âˆˆğ¸,ğ‘¦=ğ‘“(ğ‘¥)\overset{\text{\scriptsize dÃ©f}}{âŸº}\overset{-1}{ğ‘“}(ğ‘¦)â‰ âˆ…\).
\end{proof}
%
\begin{proposition}
Tout prolongement d'une surjection est une surjection.
\end{proposition}
\begin{proof}
En exercice...
\end{proof}
%
\begin{definition}
[Image]
Soit \(ğºâŠ‚ğ¸\) et \(ğ‘“:ğ¸â†’ğ¹\), \(\left\{ğ‘¦âˆˆğ¹\middle|âˆƒğ‘¥âˆˆğº\text{, }ğ‘¦=ğ‘“(ğ‘¥)\right\}\)
est l'\mykeyword{image} de \(ğº\) par \(ğ‘“\), notÃ© \(ğ‘“(ğº)\).
L'\mykeyword{image} de \(ğ‘“\) est \(ğ‘“(ğ¸)\) aussi notÃ©e \(\Im ğ‘“\) .
\end{definition}
%
\begin{theorem}
\label{thm:surctive}
Une application \(ğ‘“\) de \(ğ¸\) dans \(ğ¹\) est surjective si et seulement si
 \(\Im ğ‘“=ğ¹\).
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
\subsection{Bijection}
\begin{definition}
[Bijection]
\(ğ¸\) et \(ğ¹\) Ã©tant des ensembles, une application \(ğ‘“\) de
\(ğ¸\) dans \(ğ¹\) est \mykeyword{bijective} ou de maniÃ¨re synonyme une
\mykeyword{bijection} si
\begin{equation*}
âˆ€ğ‘¦âˆˆğ¹,\;âˆƒ~!ğ‘¥âˆˆğ¸,\;ğ‘¦=ğ‘“(ğ‘¥)
\end{equation*}
\end{definition}
%
\begin{theorem}
L'application vide de \(âˆ…\) dans lui-mÃªme est bijective.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
%
\begin{theorem}
L'application de \(ğ¸\) dans \(ğ¸\) qui Ã  tout Ã©lÃ©ment associe lui-mÃªme est une bijection, elle est notÃ©
\(\operatorname{Id}_{ğ¸}\)
\end{theorem}
\begin{proof}
Ã€ complÃ©ter...
\end{proof}
%
\begin{definition}
 \(ğ¸\) et \(ğ¹\) sont en bijection, ou \mykeyword{Ã©quipotents}, signifie qu'il existe une bijection de \(ğ¸\)
 sur \(ğ¹\) .
\end{definition}
%
\begin{theorem}
\label{thm:bijection}
Une application \(ğ‘“\) est une bijection si et seulement si pour tout \(ğ‘¦\) de son ensemble d'arrivÃ©e,
\(\overset{-1}{ğ‘“}(ğ‘¦)\) est un singleton.
\end{theorem}
\begin{proof}
On a \(âˆƒ~!ğ‘¥âˆˆğ¸,\;ğ‘¦=ğ‘“(ğ‘¥)âŸº\overset{-1}{ğ‘“}(ğ‘¦)\text{ est un singleton}\).
\end{proof}
\begin{theorem}
Toute injection induit une bijection sur son image.
\end{theorem}
\begin{proof}
Soit \(ğ‘“~:ğ¸â†’ğ¹\). Son graphe \(Î“\), en tant que partie de \(ğ¸Ã—\Im ğ‘“\), dÃ©finit une application de \(ğ¸\) dans \(\Im
ğ‘“\) , qui est une bijection. Ã€ complÃ©ter...
\end{proof}
%
\begin{theorem}
\label{thm:bijection2}
Une application est une bijection si et seulement si c'est une injection et une surjection.
\end{theorem}
\begin{proof}
C'est une application des lemmes \ref{seq:refTheorem5} et \ref{seq:refTheorem8}.
\end{proof}
%
\begin{theorem}
Ã‰tant donnÃ©s \(ğ‘\) et \(ğ‘\) de \(ğ¸\),
\begin{equation*}
\begin{matrix}
ğœ~:&ğ¸&âŸ¶&ğ¸\\&ğ‘¥&âŸ¼&\left\{
\begin{matrix}ğ‘~\text{ si }~ğ‘¥=ğ‘
\\ğ‘~\text{ si }~ğ‘¥=ğ‘\hfill\null
\\ğ‘¥\text{ sinon}\hfill\null \end{matrix}
\right.\end{matrix}
\end{equation*}
 \(ğœ\) est une bijection.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
\subsection{Composition}
\begin{definition}
[Composition]
\(ğ¸\), \(ğ¹\) et \(ğº\) Ã©tant des ensembles,
\(ğ‘“\) Ã©tant une application de \(ğ¸\) dans \(ğ¹\) et \(ğ‘”\) une application
de \(ğ¹\) dans \(ğº\) , l'application \(ğ‘¥â†¦ğ‘”(ğ‘“(ğ‘¥))\) est notÃ©e \(ğ‘”âˆ˜ğ‘“\), c'est l'application
\mykeyword{composÃ©e} de \(ğ‘”\) par \(ğ‘“\).
\end{definition}
%
\begin{theorem}
La composition est associative : \((â„âˆ˜ğ‘”)âˆ˜ğ‘“=â„âˆ˜(ğ‘”âˆ˜ğ‘“)\).
\end{theorem}
\begin{proof}
On a \((â„âˆ˜ğ‘”)âˆ˜ğ‘“(ğ‘¥)=(â„âˆ˜ğ‘”)(ğ‘“(ğ‘¥))=â„(ğ‘”(ğ‘“(ğ‘¥)))=â„((ğ‘”âˆ˜ğ‘“(ğ‘¥)))=â„âˆ˜(ğ‘”âˆ˜ğ‘“)(ğ‘¥)\).
\end{proof}
\begin{remark}
La composition n'est pas commutative. En gÃ©nÃ©ral, on a trois ensembles
de dÃ©part ou d'arrivÃ©e mutuellement diffÃ©rents, pour avoir la commutativitÃ©,
il en faut nÃ©cessairement deux au total et pas plus.
\end{remark}
%
\begin{theorem}
\begin{enumerate}
\item La composÃ©e de deux applications injectives et injective.
\item La composÃ©e de deux applications surjectives et surjective.
\item La composÃ©e de deux applications bijectives et bijective.
\end{enumerate}
\end{theorem}
\begin{proof}
\par\noindent
\begin{enumerate}
\item On a \(ğ‘¥â‰ ğ‘¦â‡’ğ‘“(ğ‘¥)â‰ ğ‘“(ğ‘¦)â‡’ğ‘”(ğ‘“(ğ‘¥))â‰ ğ‘”(ğ‘“(ğ‘¦))\).
\item Avec les notations de la dÃ©finition de composition, on a
\(âˆ€ğ‘§âˆˆğº\text{, }âˆƒ~ğ‘¦_{ğ‘§}âˆˆğ¹\text{, }ğ‘§=ğ‘”(ğ‘¦_{ğ‘§})\) et
\(âˆ€ğ‘¦âˆˆğ¹\text{, }âˆƒ~ğ‘¥_{ğ‘¦}âˆˆğ¸\text{, }ğ‘¦=ğ‘“(ğ‘¥_{ğ‘¦})\).
En particulier, \(ğ‘§=ğ‘”âˆ˜ğ‘“(ğ‘¥_{ğ‘¦_{ğ‘§}})\).
\item Par les point prÃ©cÃ©dents ainsi que la proposition \ref{seq:refTheorem15}.
\end{enumerate}
\end{proof}
%
\begin{definition}
[Application rÃ©ciproque, Ã  gauche, Ã  droite]
\(ğ¸\) et \(ğ¹\) Ã©tant des ensembles,
\(ğ‘“\) Ã©tant une application de \(ğ¸\) dans \(ğ¹\) et
\(ğ‘”\) une application de \(ğ¹\) dans \(ğ¸\).
\begin{enumerate}
\item \(ğ‘”\) est \mykeyword{rÃ©ciproque Ã  gauche} de \(ğ‘“\) signifie que
\(ğ‘”âˆ˜ğ‘“=\operatorname{Id}_{ğ¸}\).
\item \(ğ‘”\) est \mykeyword{rÃ©ciproque Ã  droite} de \(ğ‘“\) signifie que
\(ğ‘“âˆ˜ğ‘”=\operatorname{Id}_{ğ¹}\).
\item \(ğ‘”\) est \mykeyword{rÃ©ciproque} de \(ğ‘“\) signifie \(ğ‘”\) est Ã  la
fois rÃ©ciproque Ã  gauche et rÃ©ciproque Ã  droite de \(ğ‘“\).
\end{enumerate}
\end{definition}
%
\begin{theorem}
\begin{enumerate}
\item Toute application injective admet une rÃ©ciproque Ã  gauche.
\item Toute application surjective admet une rÃ©ciproque Ã  droite.
\item Toute application bijective admet une rÃ©ciproque, qui est unique et Ã  la fois rÃ©ciproque Ã  gauche et Ã  droite.
\end{enumerate}
\end{theorem}
\begin{proof}
On note \(ğ‘“~:ğ¸â†’ğ¹\) , \(ğ‘”~:ğ¹â†’ğ¸\) , \(Î“_{ğ‘“}\) le graphe de \(ğ‘“\) et \(Î“_{ğ‘”}\) celui de \(ğ‘”\).
Soit \(ğº\overset{\text{\scriptsize dÃ©f}}{=}\left\{(ğ‘¦;ğ‘¥)\left|(ğ‘¥;ğ‘¦)âˆˆÎ“_{ğ‘“}\right.\right\}\).
On laisse en exercice le cas oÃ¹ l'un des deux ensembles est vide. Ã€ complÃ©ter...
\begin{enumerate}
\item Si \(ğ‘“\) est injective. Soit \(ğ‘¥_0âˆˆğ¸\) et \(ğº'\overset{\text{\scriptsize dÃ©f}}{=}\left\{(ğ‘¦;ğ‘¥_0)\middle|ğ‘¦âˆ‰\Im
ğ¹\right\}\), \(ğºâˆªğº\)' est le graphe d'une application rÃ©ciproque Ã  gauche de \(ğ‘“\). Ã€ complÃ©ter...
\item Si \(ğ‘“\) est surjective. Par l'axiome du choix, il existe une application \(ğœ‘\) qui Ã  tout
\(\overset{-1}{ğ‘“}(ğ‘¦)\) associe l'un de ses Ã©lÃ©ments. L'application \(ğœ‘\) est un inverse Ã  droite de \(ğ‘“\).

Si \(ğ¸\) est dÃ©nombrable, il peut Ãªtre muni d'une relation d'ordre total\footnote{Ã€ dÃ©tailler...} ce qui permet d'Ã©viter
l'axiome du choix : on prend \(ğœ‘~:ğ‘¦â†¦\operatorname{min}\overset{-1}{ğ‘“}(ğ‘¦)\).

\item Si \(ğ‘“\) est bijective, on a une rÃ©ciproque Ã  gauche et une rÃ©ciproque Ã  droite : \(ğ‘”âˆ˜ğ‘“=\operatorname{Id}_{ğ¸}\)
 et \(ğ‘“âˆ˜ğ‘”'=\operatorname{Id}_{ğ¹}\) . Par associativitÃ©, \(ğ‘”=ğ‘”âˆ˜(ğ‘“âˆ˜ğ‘”')=(ğ‘”âˆ˜ğ‘“)âˆ˜ğ‘”'=ğ‘”'\) , donc \(ğ‘”\) est rÃ©ciproque
de \(ğ‘“\), mais aussi rÃ©ciproque Ã  gauche et Ã  droite.
L'unicitÃ© vient de
\(ğ‘”âˆ˜ğ‘“=â„âˆ˜ğ‘“=\operatorname{Id}â‡’(ğ‘”âˆ˜ğ‘“)âˆ˜ğ‘”=(â„âˆ˜ğ‘“)âˆ˜ğ‘”â‡’ğ‘”âˆ˜(ğ‘“âˆ˜ğ‘”)=â„âˆ˜(ğ‘“âˆ˜ğ‘”)â‡’ğ‘”=â„\).
\end{enumerate}
\end{proof}
\begin{definition}
On note \(ğ‘“^{-1}\) la rÃ©ciproque de \(ğ‘“\).
\end{definition}
%
\begin{theorem}
\begin{enumerate}
\item Si \(ğ‘”âˆ˜ğ‘“\) est injective alors \(ğ‘“\) est injective.
\item Si \(ğ‘”âˆ˜ğ‘“\) est surjective, alors \(ğ‘”\) est surjective.
\item Si \(ğ‘”âˆ˜ğ‘“\) est bijective, \(ğ‘”_{\left|\Im ğ‘“\right.}\) est une bijection.
\end{enumerate}
\end{theorem}
\begin{proof}
\par\noindent
\begin{enumerate}
\item Si \(ğ‘“\) n'est pas injective, on a \(ğ‘“(ğ‘¥)=ğ‘“(ğ‘¥')\) avec \(ğ‘¥â‰ ğ‘¥'\),
d'oÃ¹ \(ğ‘”âˆ˜ğ‘“(ğ‘¥)=ğ‘”âˆ˜ğ‘“(ğ‘¥')\) et \(ğ‘”âˆ˜ğ‘“\)
n'est pas injective. On a le rÃ©sultat par contraposition.
\item Notons \(ğ‘“~:ğ¸â†’ğ¹\) et \(ğ‘”~:ğºâ†’ğ»\). Si \(ğ‘”âˆ˜ğ‘“\) est surjective, on a \(ğ‘”(ğ‘“(ğ¸))~=ğ»\).
Comme on a \(ğ‘“(ğ¸)âŠ‚ğ¹\), on a aussi \(ğ‘”(ğ‘“(ğ¸))âŠ‚ğ‘”(ğ¹)\).
Cela donne \(ğ»âŠ‚ğ‘”(ğ¹)âŠ‚ğ»\) puis \(ğ‘”(ğ¹)=ğ»\) et la surjectivitÃ© de \(ğ‘”\).
\item Par 1, \(ğ‘“\) est injective, soit \(ğ‘“_b\) la bijection qu'elle induit sur \(\Im ğ‘“\) . On a \(ğ‘”âˆ˜ğ‘“=ğ‘”_{\left|\Im
ğ‘“\right.}âˆ˜ğ‘“_b\) et \(ğ‘”_{\left|\Im ğ‘“\right.}=(ğ‘”âˆ˜ğ‘“)âˆ˜ğ‘“_b^{-1}\) qui est la composÃ©e de deux bijections.
\end{enumerate}
\end{proof}
%
\begin{theorem}
\begin{enumerate}
\item Toute application qui admet une rÃ©ciproque Ã  gauche est injective.
\item Toute application qui admet une rÃ©ciproque Ã  droite est surjective.
\item Toute application qui admet une rÃ©ciproque est bijective.
\end{enumerate}
\end{theorem}
\begin{proof}
Si on a \(ğ‘”âˆ˜ğ‘“=\operatorname{Id}_{ğ¸}\) , sachant que \(\operatorname{Id}_{ğ¸}\) est Ã  la fois injective et surjective,
\(ğ‘”\) est surjective et \(ğ‘“\) injective. Si on a en plus \(ğ‘“âˆ˜ğ‘”=\operatorname{Id}_{ğ¹}\) , \(ğ‘”\) est aussi injective et
 \(ğ‘“\) surjective, les deux sont des bijections.
\end{proof}
\begin{theorem}
Une rÃ©ciproque Ã  gauche est surjective, une rÃ©ciproque Ã  droite injective.
\end{theorem}
\begin{proof}
En exercice...
\end{proof}
